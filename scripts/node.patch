diff --git a/lib/internal/modules/cjs/loader.js b/lib/internal/modules/cjs/loader.js
index 64505220ab..637bf82159 100644
--- a/lib/internal/modules/cjs/loader.js
+++ b/lib/internal/modules/cjs/loader.js
@@ -63,6 +63,10 @@ const manifest = getOptionValue('--experimental-policy') ?
   require('internal/process/policy').manifest :
   null;
 const { compileFunction } = internalBinding('contextify');
+// NOTE@coder: Modules used in our customizations below.
+const nbin = require('nbin');
+const os = require('os');
+const zlib = require('zlib');
 
 const {
   ERR_INVALID_ARG_VALUE,
@@ -118,7 +122,11 @@ function stat(filename) {
     const result = statCache.get(filename);
     if (result !== undefined) return result;
   }
-  const result = internalModuleStat(filename);
+  // NOTE@coder: Try loading from within the binary.
+  const s = nbin.statSync(filename);
+  const result = s.isDirectory ?
+    1 :
+    (s.isFile ? 0 : internalModuleStat(filename));
   if (statCache !== null) statCache.set(filename, result);
   return result;
 }
@@ -224,7 +232,13 @@ function readPackage(requestPath) {
   const existing = packageJsonCache.get(jsonPath);
   if (existing !== undefined) return existing;
 
-  const json = internalModuleReadJSON(path.toNamespacedPath(jsonPath));
+  // NOTE@coder: Try loading from the binary.
+  let json;
+  if (nbin.existsSync(jsonPath)) {
+    json = nbin.readFileSync(jsonPath, 'utf8');
+  } else {
+    json = internalModuleReadJSON(path.toNamespacedPath(jsonPath));
+  }
   if (json === undefined) {
     packageJsonCache.set(jsonPath, false);
     return false;
@@ -334,6 +348,10 @@ function tryFile(requestPath, isMain) {
 }
 
 function toRealPath(requestPath) {
+  // NOTE@coder: Try loading from the binary.
+  if (nbin.existsSync(requestPath)) {
+    return requestPath;
+  }
   return fs.realpathSync(requestPath, {
     [internalFS.realpathCacheKey]: realpathCache
   });
@@ -991,14 +1009,32 @@ Module._extensions['.js'] = function(module, filename) {
       }
     }
   }
-  const content = fs.readFileSync(filename, 'utf8');
+  // NOTE@coder: Try loading from within the binary.
+  let content;
+  if (nbin.existsSync(filename)) {
+    content = nbin.readFileSync(filename, 'utf8');
+  } else {
+    content = fs.readFileSync(filename, 'utf8');
+  }
+  module._compile(stripBOM(content), filename);
+};
+
+// NOTE@coder: Native extension for .gz
+Module._extensions['.gz'] = function(module, filename) {
+  const content = zlib.gunzipSync(nbin.readFileSync(filename)).toString('utf8');
   module._compile(stripBOM(content), filename);
 };
 
 
 // Native extension for .json
 Module._extensions['.json'] = function(module, filename) {
-  const content = fs.readFileSync(filename, 'utf8');
+  // NOTE@coder: Try loading from within the binary.
+  let content;
+  if (nbin.existsSync(filename)) {
+    content = nbin.readFileSync(filename, 'utf8');
+  } else {
+    content = fs.readFileSync(filename, 'utf8');
+  }
 
   if (manifest) {
     const moduleURL = pathToFileURL(filename);
@@ -1017,12 +1053,34 @@ Module._extensions['.json'] = function(module, filename) {
 // Native extension for .node
 Module._extensions['.node'] = function(module, filename) {
   if (manifest) {
-    const content = fs.readFileSync(filename);
+    // NOTE@coder: Try loading from within the binary.
+    let content;
+    if (nbin.existsSync(filename)) {
+      content = nbin.readFileSync(filename);
+    } else {
+      content = fs.readFileSync(filename);
+    }
     const moduleURL = pathToFileURL(filename);
     manifest.assertIntegrity(moduleURL, content);
   }
   // Be aware this doesn't use `content`
-  return process.dlopen(module, path.toNamespacedPath(filename));
+  // NOTE@coder: Try extracting from the binary to a temporary directory.
+  let isInternal = false;
+  if (nbin.existsSync(filename)) {
+    const tmpDir = path.join(os.tmpdir(), 'nbin', nbin.version);
+    const tmpFile = path.join(tmpDir, path.basename(filename));
+    if (!fs.existsSync(tmpFile)) {
+      fs.mkdirSync(path.dirname(tmpDir));
+      fs.mkdirSync(tmpDir);
+      fs.writeFileSync(tmpFile, nbin.readFileSync(filename));
+    }
+    filename = tmpFile;
+    isInternal = true;
+  }
+  return process.dlopen(
+    module,
+    isInternal ? filename : path.toNamespacedPath(filename)
+  );
 };
 
 Module._extensions['.mjs'] = function(module, filename) {
diff --git a/src/node.cc b/src/node.cc
index ae53d0c31c..76e4b9cf66 100644
--- a/src/node.cc
+++ b/src/node.cc
@@ -663,6 +663,11 @@ int ProcessGlobalArgs(std::vector<std::string>* args,
   // Parse a few arguments which are specific to Node.
   std::vector<std::string> v8_args;
 
+  // NOTE@coder: If we aren't bypassing nbin, don't process the arguments.
+  if (!getenv("NBIN_BYPASS") && !is_env) {
+    return 0;
+  }
+
   Mutex::ScopedLock lock(per_process::cli_options_mutex);
   options_parser::Parse(
       args,
